# About_Web
<h1>브라우저 <-> front(client) <-> server 와의 통신 흐름과 관계를 알아보도록 하겠습니다</h1>
<strong>axios, node-express, mysql-sequelize 를 이용하여 서버,DB 와 의 통신을 실행하겠습니다.</strong>
<p>아래의 목차에 대해 진행됩니다.</p>
<ul>
  <li>브라우저 - 렌더링</li>
  <li>front - 통신</li>
  <li>server - 통신</li>
</ul>

<h2>1. 브라우저 - 렌더링</h2>
<p>Client는 서버와 통신할수 있는 모든 소프트웨어 입니다. 대표적인 예로 브라우저가 있습니다.</p>
<p>웹에 대해 다루고 있기 때문에 브라우저의 목적, 특징을 알아보겠습니다.</p>
<p>브라우저는 렌더링된 결과물을 시각적으로 보여주는걸 목표로 가지고 있습니다. <br>
    렌더링 이란 서버로 부터 HTML 파일을 받아 브라우저에 뿌려주는 과정을 의미합니다. <br>
    보통 웹은 html이 뼈대, css가 꾸며주기, javascript가 동작을 나타내기 때문에 이 3가지를 받아옵니다. <br>
</p>
<p>렌더링을 하는 주체는 브라우저 입니다.(Chrome, IE, Whale, ...) 브라우저가 렌더링을 위해 서버에게 HTML파일(리소스)을 요청(request)하고
    서버는 해당 파일(리소스)을 보내줍니다.(응답-response).
</p>
<ul>
    <li>렌더링을 하는 주체는 브라우저 입니다.(Chrome, IE, Whale, ...) 브라우저가 렌더링을 위해 서버에게 HTML파일(리소스)을 요청(request)하고
        서버는 해당 파일(리소스)을 보내줍니다.(응답-response).</li>
    <li>브라우저 렌더링 엔진은 해당 HTML파일을 위에서 아래로, 동기적으로 파싱을 하며 DOM을 생성합니다. 그러다가 css-link, img-tag, js-script 같은걸 만나면
        HTML파싱을 중지하고 서버로 해당 파일을 request보내고 response 받습니다.
        CSS도 동일한 파싱 과정을 거쳐 CSSOM을 생성하고, 그 후 다시 HTML파싱과 DOM생성을 이어서 진행합니다.
        이렇게 html,css의 파싱 결과물인 DOM,CSSOM을 결합하여 Render Tree를 생성합니다.
    </li>
    <li>html을 계속 파싱하는 중에 css처럼 script-js를 만나면 다시 html파싱을 멈추고 js파일을 서버로부터 받아 js를 파싱합니다.
        js파일은 브라우저 엔진이 아니라 자바스크립트 엔진이 진행을 합니다. 위와 비슷하게 파싱을 하여 AST를 생성하며 이는 인터프리터가 실행할 수
         있는 중간 코드인 바이트코드로 변환되고 인터프리터에 의해 실행됩니다.
    </li>
    <li>만약 js파일에 DOM이나 CSSOM을 변경하는 DOM API가 사용 되었다면 DOM, CSSOM이 변경되고 변경된걸로 다시 Render Tree로 결합이 됩니다.
        렌더트리로 레이아웃을 만들고 브라우저 화면에 픽셀을 렌더링하는 페인팅 과정을 거칩니다.
        즉 js파일에서 DOM, CSSOM을 변경하였다면 렌더트리가 바뀌기 때문에 리플로우(레이아웃 계산을 다시 하는것)와 리페인팅(재결합된 Render Tree로 다시 페인팅 하는것)을 실행합니다.
    </li>
</ul>
